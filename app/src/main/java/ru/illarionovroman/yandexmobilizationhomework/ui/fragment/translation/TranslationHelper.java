package ru.illarionovroman.yandexmobilizationhomework.ui.fragment.translation;


import android.content.Context;
import android.support.annotation.NonNull;
import android.text.TextUtils;
import android.widget.TextView;

import com.jakewharton.rxbinding2.widget.RxTextView;

import java.util.List;
import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.Single;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.functions.Function;
import io.reactivex.schedulers.Schedulers;
import ru.illarionovroman.yandexmobilizationhomework.R;
import ru.illarionovroman.yandexmobilizationhomework.db.DBManager;
import ru.illarionovroman.yandexmobilizationhomework.model.HistoryItem;
import ru.illarionovroman.yandexmobilizationhomework.network.RestApi;


public class TranslationHelper {

    private static final int USER_INPUT_UPDATE_TIMEOUT_SECONDS = 2;

    /**
     * Rx watcher for user input in the EditText. After every valid update initiates translation
     * loading procedure
     * @param textView {@link TextView} to watch for
     * @param currentItem
     * @return {@link Observable<String>} which watches for filtered changes of passed TextView
     */
    @NonNull
    public static Observable<String> createInputWatcher(@NonNull TextView textView,
                                                        HistoryItem currentItem) {
        return RxTextView.textChanges(textView)
                .skipInitialValue()
                // RxBinding doc for textChanges() says that charSequence is mutable, get rid of it.
                .map(String::valueOf)
                .map(String::trim)
                .distinctUntilChanged()
                .debounce(USER_INPUT_UPDATE_TIMEOUT_SECONDS, TimeUnit.SECONDS)
                .filter(inputText -> !TextUtils.isEmpty(inputText))
                .filter(inputText -> {
                    // Don't pass if the same item is currently displayed
                    if (currentItem != null && inputText.equals(currentItem.getWord())) {
                        return false;
                    } else {
                        return true;
                    }
                });
    }

    /**
     * The common scheme is as follows: at first, we are trying to get translation from DB,
     * if there is no such translation that we are looking for, then try to get it from the server
     * @param wordToTranslate
     * @param langCodeFrom Language code to translate from
     * @param langCodeTo Language code to translate to
     * @return {@link HistoryItem} from DB or network
     */
    public static Single<HistoryItem> loadHistoryItem(final Context context,
                                                      final RestApi restApi,
                                                      final String wordToTranslate,
                                                      final String langCodeFrom,
                                                      final String langCodeTo) {
        return Single.just(wordToTranslate)
                .flatMap(new Function<String, Single<HistoryItem>>() {
                    @Override
                    public Single<HistoryItem> apply(String word) throws Exception {
                        // Try to find this word in database
                        HistoryItem historyItem = DBManager.getHistoryItemByWordAndLangs(
                                context,
                                word,
                                langCodeFrom,
                                langCodeTo);
                        if (historyItem == null) {
                            historyItem = new HistoryItem();
                        }
                        return Single.just(historyItem);
                    }
                })
                .flatMap(new Function<HistoryItem, Single<HistoryItem>>() {
                    @Override
                    public Single<HistoryItem> apply(HistoryItem historyItem) throws Exception {
                        if (historyItem.getId() != HistoryItem.UNSPECIFIED_ID) {
                            // If found in DB - just return
                            return Single.just(historyItem);
                        } else {
                            // If not found - do network request
                            return loadHistoryItemFromNetwork(context, restApi, wordToTranslate,
                                    langCodeFrom, langCodeTo);
                        }
                    }
                })
                // Do the work with DB and network in background thread
                .subscribeOn(Schedulers.io())
                // Show the result in UI thread
                .observeOn(AndroidSchedulers.mainThread());
    }

    /**
     * Perform network request, transform response to desired HistoryItem. This is reachable
     * only through DB write and read to obtain autogenerated item's ID and Date
     */
    private static Single<HistoryItem> loadHistoryItemFromNetwork(final Context context,
                                                                  final RestApi restApi,
                                                                  final String wordToTranslate,
                                                                  final String langCodeFrom,
                                                                  final String langCodeTo) {
        String langFromTo = buildTranslationLangParam(context, langCodeFrom, langCodeTo);

        Single<HistoryItem> historyItemSingle = restApi.getTranslation(wordToTranslate, langFromTo, null)
                .map(translationResponse -> {
                    // Pull data from response
                    StringBuilder translationBuilder = new StringBuilder();
                    List<String> translations = translationResponse.getTranslations();
                    for (int i = 0; i < translations.size(); i++) {
                        translationBuilder.append(translations.get(i));
                        if (i != translations.size() - 1) {
                            translationBuilder.append("\n");
                        }
                    }
                    // Create incomplete item
                    HistoryItem item = new HistoryItem(
                            wordToTranslate,
                            translationBuilder.toString(),
                            langCodeFrom,
                            langCodeTo
                    );
                    // Write it to DB
                    long id = DBManager.addHistoryItem(context, item);
                    // Now we can get the completed item
                    HistoryItem resultItem = DBManager.getHistoryItemById(context, id);
                    return resultItem;
                });
        return historyItemSingle;
    }

    /**
     * Method for building parameter for translation request using currently selected languages.
     * @return E.g.: "ru-en", "en-ru", etc.
     */
    private static String buildTranslationLangParam(Context context,
                                                    String langCodeFrom, String langCodeTo) {
        return context.getString(R.string.translate_query_param_language_from_to,
                langCodeFrom, langCodeTo);
    }
}
